;This will be the syntax checker for TLS

;Design idea for Inductive defeniton

; So given the language of TLS we are supposed to create a syntax checker that checks if what the user put in as code
;has correct syntax which include but not limited to
;;     basic errors such as malformed cond and lambda expressions; (ii) detect when primitives are
;;     applied to the wrong number of arguments; and (iii) detect the presence of unbound variables.

(load "Project.rkt") 


;In class we went over the specifications of a "Module Dispatch" and how it should work in the TLS system with the syntax checker
;this will serve as out dispatch where we 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TLS Module Dispatch (Used by Syntax Checker)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (tls-module dispatch)
  (cond
    ((eq? dispatch 'primitives)
     '(car cdr cons null? pair? list? equal? atom? not
           + - * / = < > <= >= symbol? number? boolean?
           procedure? zero? add1 sub1 first second third))
    ((eq? dispatch 'special-forms)
     '(lambda cond if quote define and or))
    (else (error "Unknown dispatch key:" dispatch))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helpers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (constant? x)
  (or (number? x) (boolean? x) (string? x) (char? x)))

(define (member? x lst)
  (cond ((null? lst) #f)
        ((eq? x (car lst)) #t)
        (else (member? x (cdr lst)))))

(define (duplicates? lst)
  (cond ((null? lst) #f)
        ((member? (car lst) (cdr lst)) #t)
        (else (duplicates? (cdr lst)))))

(define (var? x env tls)
  (or (member? x env) (member? x (tls 'primitives))))

(define (gathers errs lst env tls)
  (cond ((null? lst) errs)
        (else (let ((result (syntax-checker (car lst) env tls)))
                (if result
                    (gathers errs (cdr lst) env tls)
                    (gathers (cons (car lst) errs) (cdr lst) env tls))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Main Syntax Checker
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (syntax-checker expr env tls)
  (cond
    ((constant? expr) #t)
    ((symbol? expr) (var? expr env tls))
    ((and (pair? expr) (eq? (car expr) 'quote))
     (and (= (length expr) 2) #t))
    ((pair? expr)
     (let ((op (car expr))
           (args (cdr expr)))
       (cond
         ((eq? op 'lambda) (check-lambda expr env tls))
         ((eq? op 'cond)   (check-cond expr env tls))
         ((eq? op 'if)     (check-if expr env tls))
         ((eq? op 'define) (check-define expr env tls))
         ((member? op (tls 'primitives))
          (and (conditions op args)
               (null? (gathers '() args env tls))))
         (else (null? (gathers '() expr env tls))))))
    (else #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Arity Checking
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (conditions name vals)
  (cond
    ((or (eq? name 'car) (eq? name 'cdr) (eq? name 'first)
         (eq? name 'second) (eq? name 'third)
         (eq? name 'pair?) (eq? name 'atom?) (eq? name 'symbol?)
         (eq? name 'number?) (eq? name 'boolean?) (eq? name 'zero?)
         (eq? name 'add1) (eq? name 'sub1))
     (= (length vals) 1))
    ((eq? name 'cons) (= (length vals) 2))
    ((or (eq? name 'equal?) (eq? name '=)
         (eq? name '<) (eq? name '>) (eq? name '<=) (eq? name '>=)
         (eq? name '+) (eq? name '-) (eq? name '*) (eq? name '/))
     (>= (length vals) 2))
    (else #f)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Form Checkers
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (check-if expr env tls)
  (and (= (length expr) 4)
       (syntax-checker (second expr) env tls)
       (syntax-checker (third expr) env tls)
       (syntax-checker (fourth expr) env tls)))

(define (check-define expr env tls)
  (cond
    ((symbol? (second expr))
     (and (= (length expr) 3)
          (syntax-checker (third expr) env tls)))
    ((and (pair? (second expr)) (symbol? (car (second expr))))
     (let* ((params (cdr (second expr)))
            (body (third expr))
            (new-env (append params env)))
       (and (not (duplicates? params))
            (syntax-checker body new-env tls))))
    (else #f)))

(define (check-lambda expr env tls)
  (and (= (length expr) 3)
       (let ((params (second expr))
             (body (third expr)))
         (and (list? params)
              (not (duplicates? params))
              (syntax-checker body (append params env) tls)))))

(define (check-cond expr env tls)
  (define (clause-check lst)
    (cond
      ((null? lst) #t)
      ((not (pair? (car lst))) #f)
      ((eq? (car (car lst)) 'else)
       (and (null? (cdr lst)) 
            (null? (gathers '() (cdr (car lst)) env tls))))
      ((< (length (car lst)) 2) #f)
      (else
       (and (syntax-checker (caar lst) env tls)
            (null? (gathers '() (cdr (car lst)) env tls))
            (clause-check (cdr lst))))))
  (and (pair? expr)
       (> (length expr) 1)
       (clause-check (cdr expr))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Free Variable Detection
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (element-lst? x lst)
  (cond ((null? lst) #f)
        ((equal? x (car lst)) #t)
        (else (element-lst? x (cdr lst)))))

(define (union-lst lst1 lst2)
  (cond ((null? lst1) lst2)
        ((element-lst? (car lst1) lst2) (union-lst (cdr lst1) lst2))
        (else (cons (car lst1) (union-lst (cdr lst1) lst2)))))

(define (free-vars expr bound)
  (cond
    ((symbol? expr)
     (if (element-lst? expr bound) '() (list expr)))
    ((constant? expr) '())
    ((and (pair? expr) (eq? (car expr) 'lambda))
     (let ((params (second expr))
           (body (third expr)))
       (free-vars body (append params bound))))
    ((and (pair? expr) (eq? (car expr) 'cond))
     (apply union-lst (map (lambda (clause)
                             (union-lst
                              (free-vars (car clause) bound)
                              (apply union-lst
                                     (map (lambda (x)
                                            (free-vars x bound))
                                          (cdr clause)))))
                           (cdr expr))))
    ((pair? expr)
     (union-lst (free-vars (car expr) bound)
                (free-vars (cdr expr) bound)))
    ((null? expr) '())
    (else '())))

(define (unbound-vars expr)
  (free-vars expr '()))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Example Tests

(define tls tls-module)

(syntax-checker '(lambda (x) (+ x 1)) '() tls) ; => #t
(syntax-checker '(+ 1) '() tls)               ; => #f
(unbound-vars '(lambda (x) (lambda (y) (+ x y z)))) ; => (z)
