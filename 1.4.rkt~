; this is 1.4 of the project



;--------------------------------------------------------------------------------------------------
;1.4 Closures and Lexical Scope in TLS
;---------------------------------------------------------------------------------------------------------
;; Question: Research closures and lexical scope, and prove that your
;; implementation of TLS supports these features correctly.
;; Provide definitions, structural insights, and use induction to justify correctness.

;----------------------------------------------------------------------------------------------------------
; Quick Background: Lexical Vs Dynamic Scoping
;--------------------------------------------------------------------------------------------------------
;1.4 of the project is asking us to research closure and lexical scope and prove that our implementation
; of TLS implements them correctly.

 
;The first part of the assignment is for background and asks us to research what exactly lexical scoping is
; our findings and research of lexical scope, along the way, we decided to do a comparison between Dynamic and Lexical scoping.



; Dynamic scoping is looked at like a  stack-like structure where the variable pushed is what's first in the scope/ innermost function. So the most recent binding variable
; is what is used even if the variable was defined in a different scope. So the most recent variable determines the value of it at run time, regardless of where
; the function was originally defined.


; Lexical scoping is when we determine the variable at compile time rather than run time. Instead of a stack, the variable
; we refer to is based on our static structure of the code. A variable is bound by the closest enclosing lambda, expression at the time the function
; is defined, not a the time it is called

; What exactly is lexical scoping?
; An item's lexical scope is the place in which it was created.
; Some variables can be declared within a specific scope and are only accessible within that region.
; Lexical Scope refers to the ability of a function scope to access variables from its parent scope so
; when there is a lexical scope innermost, inner, and outermost functions may access all the variables from
; their parent scopes all the way up to the global scope.
; However, one key detail is that a scope cannot access variables from functions defined inside of it,
; so the child's function is lexically bound to the parent's function.


; Basic example to show the difference between dynamic and lexical scoping

; (define y 10)
; (define (h) y)
; (define (ad) (let ((y 20)) (h)))

; In lexical scoping, ad would return 10 because h was defined in an environment
; In dynamic scoping, ad would return 20 because h is called inside the scope of y=20.


;--------------------------------------------------------------------------------------------------------
;Key concepts
;--------------------------------------------------------------------------------------------------------


; Now that we've explained the key differences between lexical and dynamic scoping, we are going to go more in-depth in explaining lexical scope.

; Important definitions:

; Bound-Occurrence: A bound occurrence is when a variable sits inside the scope that it introduces in. Bound has a binding right there
; Free occurrence:  a variable that is not introduced locally and not bound by a local binding. Free to look outside the local scope
; Unbound occurrence: a variable that is undefined. Unbound is owned by no one.

; What is a closure?

;a closure is the run-time value produced when a function is created inside some lexical environment
;a closure also gives a function access to its outer scope




; ------------------------------------------------------------------------------
   ; TLS Implementation of Lexical Scope and Closures
; ------------------------------------------------------------------------------

;A lambda expression is converted into a closure by capturing the current environment.
;
;(define (*lambda e table)
 ; (build 'non-primitive (cons table (cdr e))))


;;(define (tls-apply-closure closure vals)
  ;(let*
      ;((saved (first closure))
      ; (formals (second closure))
       ;(body (third  closure))
       ;(new-env (extend-table formals vals saved)))
  ;  (meaning body new-env)))



;(define (*identifier e table) 
;  (apply-env table e) )


; These code snippets demonstrate lexical scoping:
; - When a lambda is created, the current table is captured into the closure.
; - When called, a new environment is built over the saved table.
; - Variable lookup always uses the environment stored in the closure.


; ------------------------------------------------------------------------------
;  Structural Induction Argument for Correctness
; ------------------------------------------------------------------------------


; How does our code demonstrate that it is lexically scoped?

;From the definition we provided above, and the snippets of code below, is what we will use to prove that
Our implementation of TLS implements lexical scoping.

; Structure:
; Creating the lambda captures the current environment.
;The function application extends the captured environment with new bindings.
; Evaluation used the extended environment via 'apply' env

;Base case:
; when-Expression is a literal no lookup occurs 
; When an expression is a variable, it gets evaluated using apply-env, which searches the stored environment

; Inductive Hypothesis: assume all the subexpressions respect Lexical scoping 

;Inductive cases:
; when Variable Reference (identifier e table) 
; apply-env searches only the static environment chain (lexical scope)
; therefore, it will maintain lexical binding

; When evaluating the lambda body
;- The body uses a closure environment and not the callers
;- Any free variables in the body refer to the bindings in the saved or above
; Thefefore, all the variables are resolved lexically based on where the function was defined in the code
; and not when it's called.

;------------------------------------------------------------------------------------
; Demonstration
;------------------------------------------------------------------------------------

; This function creates a closure over x:




 ((lambda (x)
   ((lambda (f)
      ((lambda (x) (f)) 20))
    (lambda () x))) 
 10)

;Since our program is Lexicaly scoped we return 10
