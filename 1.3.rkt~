
;----------------------------------------------------------------------------------------------------
;1.3
;------------------------------------------------------------------------------------------------------


;; 1.3 After giving a specification for the environment subsystem of TLS, prove that your implementation
;;     satisfies this specification.  Then change the representation of environemnts to use lists of
;;     bindings rather than the names-values pairs shown in the text, and show that the altered
;;     representation both satisfies your specification and works with the rest of the interpreter.


;------------------------------------------------------------------------------------------------
;Specs of the  current Enviorment
;----------------------------------------------------------------------------------------------------
;So first we must give a spec for the enviorment subsystem in TLS and then we have to prove that
; our implementation fufills that specification.


;In TLS the enviorment refers to the table, which is a list of entires, and each entry consistes of varible bindinds
;which are repsented as a key value pair like:
;(( x y z)( 1 2 3))
;The first list contains the names of the varible and the second one the values.

;They key functions in the Current TLS are:
;-empty-env: returns an empty tavle ()
;-build : constructs an entry froma  list of names and a list of values
;-extend-table: preappends a new entry to the enviorment
;-lookup in entry: searches for a name in a single entry
;lookup-in-table:reccursivly searchs throigh the table for a binding




;-----------------------------------------------------------------------------------------------
;Function conditions
;----------------------------------------------------------------------------------------------

;empty-env
;Pre condtion: none since
;Post condtion: returns '()

;build
;Precondtion: names is a list of unique symbols which has the same len as values
;Post condtion: returns a pair of (names.values)

;extend-table
;Precondtion: entry is produced by build,the table is a list of entries
;Post condtion: returns a new table with the entry prepended

;Lookup-in-entry
;Precondtion:entry is a pair(names . values)
;Post condtion: returns the value at a postion of name in names,else calls entry-f

;lookup-in-table
;precondition:table is a list of entries
;Postcondtion: searces each entry using lookup-in-entry, else it calls table-f
;-----------------------------------------------------------------------------------------------
;PROOFS on our functions
;---------------------------------------------------------------------------------------------

;Proof empty env:
;Returns '(). Any lookup falls through and calls table-f, which is the correct behavior for an unbound varible

;Proof  Build
;Constructs an entry by pairing names and values. The invarient we mantain is list-ref = name i =n
; which means that the list-ref values i is bound to n

;Proof lookup-in-entry
;Base case:the length of our list is empty so we execute (entry-f name) since no correct binding exists.

;Inductive Hyptothesis: assume the propeties holds for rest-ns

;inductive step: if (car names) mathces the query then we return (car values) since they are bounded to one another
;otherwise we reccur on (cdr names) and (cdr values) ensuring that the name value pairing remains true.


;Proof lookup-in-table
;Base case: the table returns empty and calls the function (table-f s)

;Inductive hypthesis: Assume that property holds for rest-table

;inductive step: Do a check on (car table) if entry contains name, return value
;else we reccur on (cdr table)


;-----------------------------------------------------------------------------------------------
;name, value pairs ->>>>>> List-of-Bindings
;-----------------------------------------------------------------------------------------------


;changing the representation of environemnts to use lists of bindings rather than the names-values pairs
;SO far our implementation consists of name value pairs in the enviorment tables,
; previously our enviorment tables :
;(( x y z)( 1 2 3))

;We want to change that into

;((x.1)(y.2)(z.3))



;In order to do this we would have to implement some of the enviorment attributes
;that we learned about in eopl.

;In eopl there are 4 important function enviormiorments
;We have empty-env,extend-env,extend-env*, and apply env

;------------------------------------------------------------------------------------------------
;The New Enviorment
;------------------------------------------------------------------------------------------------
( define empty-env '())


;Proofs on The new enviorment

;Precondition: env is a list of (name . val) bindings.

;Postcondition: Returns a new environment with (name val) added to the front.

(define (extend-env name val env) 
  (cons (list name val) env))

;Base case: If names is null then vals should also be null so program returns the env

;Inductive hypothesis: Assume that for the lists rest-names and rest-vals,the enviorment correctly
;extends for all other bindings from rest-names to rest-vals

;Inductive step:we let our names be (cons name rest-names) and our values be (cons val rest-vals)
;this will result in our extend*env looking like extend*env rest-names rest-vals(extend-env name val env)
;Via the defention of our IH our extend*env should add all the bindings from rest-names and rest-vals
;Via the proof from extend-env our env(car names)(car vals) should be added to the front.
;Therfore the full call builds and enviorment with the bindings from names and vals.

(define (extend-env* names vals env)
  (if (null? names)
      env
      (extend-env* (cdr names)
                   (cdr vals)
                   (extend-env (car names) (car vals) env))))

;Base case:The lookup is unsucsesfull and returns an error
;Inductive hypothesis:Assume for the tail rest-env,(apply-env rest-env name) returns the value for the name
;Inductive step: our env =( cons binding rest-env)
;if the name matches the cadr of env then we return it with the correct value, if we dont then we keep on reccuring
;Via the IH our function returns the correct result until either the value is found or we run into an error.
(define(apply-env env name)
  (cond ((null? env)
         (error 'apply env(format "unbound identifier: ~a" name))) 
        ((eq? name (car(car env)))
         (cadr(car env)))
        (else
         (apply-env(cdr env) name))))


;-------------------------------------------------------------------------------------------------
;Transforming the rest of the code for compatibility
;------------------------------------------------------------------------------------------------

;Since we defined a new enviorment we have to change some of the functions in order to ensure compatibility
; Old version used:
; (define (extend-table formals vals table)
;   (cons (build formals vals) table))

;New version:
(define (extend-table formals vals table)
  (extend-env* formals vals table))

;Old version used
; (define (*identifier e table)
;   (lookup-in-table e table initial-table))

;New Version:(in the bottom of the code)
;( defined in code)(Put line of it once done)
;(define (*identifier e table)
  ;(apply-env table e))


;--------------------------------------------------------------------------------------------
;Spec analyzation
;--------------------------------------------------------------------------------------------
;1.3 also asks us to show that our newly defineed enviorment fufills the previous specs we defined
;;The key functions in the Current TLS are:
;-empty-env: returns an empty table ()
;-build : constructs an entry from a  list of names and a list of values
;-extend-table: preappends a new entry to the enviorment
;-lookup in entry: searches for a name in a single entry
;lookup-in-table:reccursivly searchs throigh the table for a binding

;In our new enviorment
;-empty-env stays as empty-env
;-build is replaced by extend env where extend env takes a name value pair and puts it in front
;-extend-table is replaced by extend-env* which preappaneds a new entry to the enviorment
;-lookup-in-entry-lookup-in-table is replaced by apply which uses reccursion and as proved fufils both the singel and reccursive binding of looking up in a enviorment and table



;------------------------------------------------------------------------------------------------
;Overall analysis and conclusion
;-----------------------------------------------------------------------------------------------

;How did alterning our lookup enviorment and enviorment in general ensure that our enviorments represent list bindings?

;Initally with our pure TLS translation our entry was two parallel lists with a name and value relatshonship.
;Lookup table would grab an entry then would find the postion of the name and return the matching value.
;  our  initial table consisted of a list of entries which relied on two diffrent lists.

;After the implementation of a new enviorment our program followed the binding model which eliminates
; the need for the name value relatshonship making the table a list of bindings
;This required all our identifiers to go through apply-env which susbstituted for lookup-in-entry and lookup-in-table.
;Once that is updated we then had to change extend-table to match our new enviorment and that required the use of extend-env* which
;instead of forming a name value pair, it pushed bindings for every actual pair so instead of (x y z)( 1 2 3) extend-env* would
;do ( x 1), ( y 2), ( z 3)

;----------------------------------------------------------------------------------------------------------------------------
;Tests
;-----------------------------------------------------------------------------------------------------------------------------

(define 13-env
  (extend-env* '(x y)
               '(1 2)
               (extend-env* '(z)
                            '(3)
                            empty-env)))

(apply-env 13-env 'x) ; => 1
(apply-env 13-env 'y) ; => 2
(apply-env 13-env 'z) ; => 3
;(apply-env test-env 'a) ; => error: unbound identifier: a

(define env1
  (extend-env* '(a b c) '(1 2 3) empty-env))

(apply-env env1 'a) ; => 1
(apply-env env1 'b) ; => 2
(apply-env env1 'c) ; => 3


(define env3
  (extend-env* '(x y) '(42 43)
    (extend-env* '(p q) '(5 6)
      (extend-env 'r 100 empty-env))))

(apply-env env3 'x) ; => 42
(apply-env env3 'p) ; => 5
(apply-env env3 'r) ; => 100
;(apply-env env3 'z) ; => error: unbound identifier

